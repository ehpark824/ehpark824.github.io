---
title: Java의 정석 기초편 01
date: 2021-01-31 22:13:25
categories:
- Java
tags:
- java
- 자바의정석
---

오랜만에 자바를 다시 하게 되어서 책을 보기로 했다.   
최근 트렌드를 반영한 책을 찾아보니, 자바의 정석 기초편이 람다, 스트림까지 포함하고 있길래 이걸로 하기.   
이 책 다 보고 나면 Effective Java 도전.  
대체 앞에만 몇번을 보는 것인가.  
그래서 이번엔 끝까지 보고 기록해 남겨보기.

<br><br>

# Chapter1 자바를 시작하기 전에

## 자바의 특징
* 자동 메모리 관리
    * 자바로 작성된 프로그램이 실행되면, 가비지컬렉터가 자동적으로 메모리를 관리해주기 때문에, 프로그래머는 메모리를 따로 관리하지 않아도 된다.
* 멀티쓰레드를 지원한다.
* 동적로딩을 지원한다.
    * 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다.

## 자바 가상 머신(JVM)
* JVM (Java virtual machin) : 자바를 실행하기 위한 가상 기계
* Java 애플리케이션은 JVM을 한번 더 거치기 때문에 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석(interpret)되기 때문에 속도가 느림
* Java 애플리케이션은 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 프로그램의 변경없이 실행이 가능한 것. (JVM은 OS에 종속적)

<br>

# Chapter2 변수
## 상수와 리터럴

* 상수(constant)
    * 변수와 달리 한번 저장하면 다른값으로 변경 할 수 없다.
    * 상수의 이름은 대문자로 하는것이 관례
    * e.g. final int MAX_SPEED = 10; 

* 리터럴(literal) : 값을 의미 
    * 변수의 값이 변하지 않는 데이터 (메모리 위치안의 값)
    * e.g. final int MAX_SPEED = 10; 
    * 위에서 MAX_SPEED는 상수, 10은 리터럴

* 리터럴의 타입과 접미사
    * JDK1.7부터 정수형 리터럴의 중간에 구분자 '_' 를 넣어 큰 숫자를 편하게 읽을 수 있게 되었다.
    * e.g. long big = 100_000_000_000L;
    * float : F, f
    * double : D, d **(실수형 기본타입)**
    * int : **정수형 기본타입** 
    * 문자 리터럴 : 'A', 반드시 하나의 문자가 필요함
        * char ch = 'A';
    * 문자열 리터럴 : "JAVA"
        * String name = "JAVA";

<br>

## 기본형과 참조형
* 기본형
    * 논리형(boolean)
    * 문자형(char)
    * 정수형(byte, short, int, long)
    * 실수형(float, double)
* 참조형
    * 기본형 8개를 제외한 나머지 타입
    * 어떤 값이 저장되어 있는 주소를 값을 갖는다.


<br>

## 정수형의 오버플로우
* 연산과정에서 타입이 표현할 수 있는 값의 범위를 넘어서는 것
* 오버플로우가 발생했다고 해서 에러가 발생하는 것은 아니다. 다만 예상했던 결과를 얻지 못할뿐

<br>

# Chapter3 연산자

## 증감연산자 ++과 -- 

|타입|설명|사용 예|
|---|---|---|---|
|전위형|값이 참조되기 **전에** 증가시킨다| j = ++i;|
|후위형|값이 참조된 **후에** 증가시킨다| j = i++;|

<br><br>

## 형변환 연산자
* 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
* 자동 형변환 :  컴파일러가 생략된 형변환을 자동적으로 추가해준다.
* 서로 다른 두 타입을 일치시키기 위해서, 형변환을 생략하면 컴파일러가 자동적으로 형변환을 해준다.
* 표현범위가 좁은 타입에서 넓은 타입으로는 자동 형변환 된다.

## 산술 변환
* 두 피연산자의 타입을 같게 일치 시킨다.(보다 큰 타입으로 일치)
    * long + int -> long + long -> long
    * float + int ->  float + float -> float
    * double + float -> double + double -> double
* 피연산자의 타입이 int 보다 작은 타입이면 int 로 변환된다.
    * byte + short -> int + int -> int
    * char + short -> int + int -> int


<br>

## Math.rount()로 반올림 하기
* Math.round() :  소수점 첫번째 자리에서 반올림
    * 다른 자리에서 반올림을 하려면 10의 n제곱으로 적적히 곱하고 나눠야 한다.
    * e.g. Math.round(3.141592 * 1000)/1000.0  
       ->  Math.round(3141.592)/1000.0  
       ->  3142/1000.0  
       ->  3.142
    * 만약 1000으로 나눴다면 결과는 3이 된다. int와 int의 나눗셈 결과는 int 이기 때문이다.

<br><br>

## 문자열의 비교
* equals() 사용
* equalsIgnoreCase() : 대소문자 구별 없음


<br>

## 조건 연산자 (삼항연산자)
e.g. result = ( x > y ) ? x : y;  
참이면 x, 거짓이면 y가 대입된다. 

